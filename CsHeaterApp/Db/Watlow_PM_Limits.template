#### Macro Definitions ####
# (s)	- Beam Line
# (ta)	- Target Area
# (ss)	- Device Name



#=========== Limits Menu ===========
# =========== Inputs
# Limits State
record(mbbi, "Cs:Source:OvenHeater:LimitState") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynUInt32Digital")
	field(INP,	"@asynMask(watlow_Lim_Enum_1.1,2,0xFF,2000)UINT16")
	field(ZRST,	"Off")
	field(ZRVL,	"62")
	field(ONST,	"None")
	field(ONVL,	"61")
	field(TWST,	"Limit High")
	field(TWVL,	"51")
	field(THST,	"Limit Low")
	field(THVL,	"52")
	field(FRST,	"Error")
	field(FRVL,	"255")
	info(archive, "Monitor, 00:00:10, VAL")
}

# Limit Status
record(mbbi, "Cs:Source:OvenHeater:LimitStatus") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynUInt32Digital")
	field(INP,	"@asynMask(watlow_Lim_Enum_1.1,16,0xFFFF,2000)INT32_BE")
	field(ZRST,	"Fail")
	field(ZRVL,	"32")
	field(ONST,	"Safe")
	field(ONVL,	"1667")
}

# Limit Output
record(mbbi, "Cs:Source:OvenHeater:LimitOutput") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynUInt32Digital")
	field(INP,	"@asynMask(watlow_Lim_Enum_1.1,4,0xFFFF,2000)INT32_BE")
	field(ZRST,	"Off")
	field(ZRVL,	"62")
	field(ONST,	"On")
	field(ONVL,	"63")
}

# =========== From the Analog Database Inputs
# Must read this input to show the value the Limit is functioning on.
# Analog Input #
record(ai, "Cs:Source:OvenHeater:AnalogInput2") 
{
	field(SCAN,	"1 second")
	field(PINI,	"YES")
	field(DTYP,	"asynFloat64")
	field(INP,	"@asyn(watlow_AI_Num_1.1,$(Ain=0),2000)FLOAT32_BE")
	field(EGU,	"°")
	field(PREC,	"3")
	field(ADEL,	"0.1")
	field(MDEL,	"0.1")
}


# =========== Read Backs
# Low Trip Setpoint
record(ai, "Cs:Source:OvenHeater:LowTripSPRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynFloat64")
	field(INP,	"@asyn(watlow_Lim_Num_1.1,4,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(EGU,	"°")
	field(MDEL,	"0.1")
}

# High Trip Setpoint
record(ai, "Cs:Source:OvenHeater:HighTripSPRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynFloat64")
	field(INP,	"@asyn(watlow_Lim_Num_1.1,6,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(EGU,	"°")
	field(MDEL,	"0.1")
}

# Limits Sides
record(mbbi, "Cs:Source:OvenHeater:LimitSidesRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynUInt32Digital")
	field(INP,	"@asynMask(watlow_Lim_Enum_1.1,0,0xFF,2000)UINT16")
	field(ZRST,	"Both")
	field(ZRVL,	"13")
	field(ONST,	"High")
	field(ONVL,	"37")
	field(TWST,	"Low")
	field(TWVL,	"53")
}

# Limit Hysteresis
record(ai, "Cs:Source:OvenHeater:LimitHysteresisRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynFloat64")
	field(INP,	"@asyn(watlow_Lim_Num_1.1,2,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(MDEL,	"0.1")
}

# Maximum Setpoint
record(ai, "Cs:Source:OvenHeater:MaxLimitSPRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
##	Need method for dynamically defining the minimum and maximum limits based upon sample environment configuration
	field(DTYP,	"asynFloat64")
	field(INP,	"@asyn(watlow_Lim_Num_1.1,16,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(MDEL,	"0.1")
}

# Minimum Setpoint
record(ai, "Cs:Source:OvenHeater:MinLimitSPRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynFloat64")
	field(INP,	"@asyn(watlow_Lim_Num_1.1,18,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(MDEL,	"0.1")
}

# Source Function A
record(mbbi, "Cs:Source:OvenHeater:LimitSourceFnARB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynUInt32Digital")
	field(INP,	"@asynMask(watlow_Lim_Enum_1.1,20,0xFFFF,2000)INT32_BE")
	field(ZRST,	"None")
	field(ZRVL,	"61")
	field(ONST,	"Digital I/O")
	field(ONVL,	"1142")
	field(TWST,	"Function Key")
	field(TWVL,	"1001")
}

# Source Instance A
#record(ai, "Cs:Source:OvenHeater:LimitSrcInstanceRB") 
#{
#	field(SCAN,	"1 second")
#	field(DTYP,	"asynInt32")
## No address defined in manual ##
#	field(INP,	"@asyn(watlow_Lim_Num_1.1,750,2000)INT32_BE")
#}

# Limits Integrate
record(mbbi, "Cs:Source:OvenHeater:LimitIntegrateRB") 
{
	field(SCAN,	"10 second")
	field(PINI,	"YES")
	field(DTYP,	"asynUInt32Digital")
	field(INP,	"@asynMask(watlow_Lim_Enum_1.1,6,0xFFFF,2000)INT32_BE")
	field(ZRST,	"No")
	field(ZRVL,	"59")
	field(ONST,	"Yes")
	field(ONVL,	"106")
}


# =========== Outputs
# Process Clear Limit Error
record(bi, "Cs:Source:OvenHeater:ClearLimitButton")
{
	field(DESC,	"Begins process to Clears Limit Errors")
	field(PINI,	"YES")
	field(VAL,	"0")
	field(ZNAM,	"Clear Error")
	field(ONAM,	"Clearing Error")
	field(ASG,	"ALWAYS")
	field(FLNK,	"Cs:Source:OvenHeater:ClearLimitCalc PP")
}

record(calcout, "Cs:Source:OvenHeater:ClearLimitCalc")
{
	field(INPA,	"Cs:Source:OvenHeater:ClearLimitButton")
	field(CALC,	"A=1")
	field(DOPT,	"Use CALC")
	field(OOPT,	"Every Time")
	field(OUT,	"Cs:Source:OvenHeater:ProcessClearLimit PP")
}


record(seq, "Cs:Source:OvenHeater:ProcessClearLimit") 
{
	field(DOL1,	"0")
	field(LNK1,	"Cs:Source:OvenHeater:ClearLimitError PP")
	field(DLY2,	"2")
	field(DOL2,	"255")
	field(LNK2,	"Cs:Source:OvenHeater:ClearLimitError PP")
	field(DOL3,	"0")
	field(LNK3,	"Cs:Source:OvenHeater:ClearLimitButton PP")
}


# Limit Clear Request
record(ao, "Cs:Source:OvenHeater:ClearLimitError") 
{
	field(SCAN,	"Passive")
	field(DTYP,	"asynInt32")
	field(OUT,	"@asynMask(watlow.w.1,720,0xFF,2000)UINT16")
}


# Low Trip Setpoint
record(ao, "Cs:Source:OvenHeater:LowTripSP") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynFloat64")
	field(OUT,	"@asyn(watlow.w.1,724,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(EGU,	"°")
	field(FLNK,	"Cs:Source:OvenHeater:LowTripSPRB")
	info(autosaveFields,	"VAL")
}

# High Trip Setpoint
record(ao, "Cs:Source:OvenHeater:HighTripSP") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynFloat64")
	field(OUT,	"@asyn(watlow.w.1,726,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(EGU,	"°")
	field(FLNK,	"Cs:Source:OvenHeater:HighTripSPRB")
	info(autosaveFields,	"VAL")
}

# Limits Sides
record(mbbo, "Cs:Source:OvenHeater:LimitSides") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynUInt32Digital")
	field(OUT,	"@asynMask(watlow.enum.w.1,728,0xFF,2000)UINT16")
	field(ZRST,	"Both")
	field(ZRVL,	"13")
	field(ONST,	"High")
	field(ONVL,	"37")
	field(TWST,	"Low")
	field(TWVL,	"53")
	field(FLNK,	"Cs:Source:OvenHeater:LimitSidesRB")
	info(autosaveFields,	"VAL")
}

# Limit Hysteresis
record(ao, "Cs:Source:OvenHeater:LimitHysteresis") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynFloat64")
	field(OUT,	"@asyn(watlow.w.1,722,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(FLNK,	"Cs:Source:OvenHeater:LimitHysteresisRB")
	info(autosaveFields,	"VAL")
}

# Maximum Setpoint
record(ao, "Cs:Source:OvenHeater:MaxLimitSP") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
##	Need method for dynamically defining the minimum and maximum limits based upon sample environment configuration
	field(DTYP,	"asynFloat64")
	field(OUT,	"@asyn(watlow.w.1,736,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(DRVL,	"-1999")
	field(DRVH,	"9999")
	field(FLNK,	"Cs:Source:OvenHeater:MaxLimitSPRB")
	info(autosaveFields,	"VAL")
}

# Minimum Setpoint
record(ao, "Cs:Source:OvenHeater:MinLimitSP") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynFloat64")
	field(OUT,	"@asyn(watlow.w.1,738,2000)FLOAT32_BE")
	field(PREC,	"3")
	field(DRVL,	"-1999")
	field(DRVH,	"9999")
	field(FLNK,	"Cs:Source:OvenHeater:MinLimitSPRB")
	info(autosaveFields,	"VAL")
}

# Source Function A
record(mbbo, "Cs:Source:OvenHeater:LimitSourceFnA") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynUInt32Digital")
	field(OUT,	"@asynMask(watlow.enum.w.1,748,0xFFFF,2000)INT32_BE")
	field(ZRST,	"None")
	field(ZRVL,	"61")
	field(ONST,	"Digital I/O")
	field(ONVL,	"1142")
	field(TWST,	"Function Key")
	field(TWVL,	"1001")
	field(FLNK,	"Cs:Source:OvenHeater:LimitSourceFnARB")
}

# Source Instance A
#record(ao, "Cs:Source:OvenHeater:LimitSrcInstance") 
#{
#	field(SCAN,	"Passive")
#	field(DTYP,	"asynInt32")
## No address defined in manual ##
#	field(OUT,	"@asyn(watlow.w.1,750,2000)INT32_BE")
#	field(DRVL,	"1")
#	field(DRVH,	"12")
#}

# Limits Integrate
record(mbbo, "Cs:Source:OvenHeater:LimitIntegrate") 
{
	field(ASG,	"$(ASG=BEAMLINE)")
	field(SCAN,	"Passive")
	field(DTYP,	"asynUInt32Digital")
	field(OUT,	"@asynMask(watlow.enum.w.1,734,0xFFFF,2000)INT32_BE")
	field(ZRST,	"No")
	field(ZRVL,	"59")
	field(ONST,	"Yes")
	field(ONVL,	"106")
	field(FLNK,	"Cs:Source:OvenHeater:LimitIntegrateRB")
	info(autosaveFields,	"VAL")
}



